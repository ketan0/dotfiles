#+TITLE: <~~karabiner config~~>
#+AUTHOR: Ketan Agrawal
#+BABEL: :cache yes
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{inconsolata}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+PROPERTY: header-args :tangle ~/.dotfiles/karabiner.edn
Created by Ketan Agrawal


inspiration taken from: 
- [[https://github.com/yqrashawn/yqdotfiles/blob/master/.config/karabiner.edn][yqrashawn]]
- [[https://github.com/nikitavoloboev/dotfiles/blob/master/karabiner/karabiner.edn][nikitavoloboev]]
- [[https://gist.github.com/kaushikgopal/ff7a92bbc887e59699c804b59074a126][kaushikgopal]]

* TODO Proper documentation--there's a reason this is in an org buffer.
* TODO Fix the bug where chrome always opens a new window
* Guide
  Guide lifted from [[https://gist.github.com/kaushikgopal/ff7a92bbc887e59699c804b59074a126][kaushikgopal]] 

  to understand better how modifiers work in karabiner
  karabiner definition of mandatory and optional
  [[https://karabiner-elements.pqrs.org/docs/json/complex-modifications-manipulator-definition/from/modifiers/#frommodifiersoptional   ][karabiner modifiers documentation]]
  need to prefix C T O S F with ! or #
** !  | means mandatory
** #  | means optional
** !! | mandatory command + control + optional + shift (hyper)
** ## | optional any
** C  | left_command
** T  | left_control
** O  | left_option
** S  | left_shift
** F  | fn
** Q  | right_command
** W  | right_control
** E  | right_option
** R  | right_shift
* Profiles
  #+begin_src clojure
    {;;beginning bracket for whole data structure!

     :profiles {
                :Ketan {:default true
                          :sim     60    ;; simultaneous_threshold_milliseconds (def: 50)
                          ;; keys need to be pressed within this threshold to be considered simultaneous
                          :delay   80    ;; to_delayed_action_delay_milliseconds (def: 500)
                          ;; basically it means time after which the key press is count delayed
                          :alone   200      ;; to_if_alone_timeout_milliseconds (def: 1000)
                          ;; hold for 995s and single tap registered; hold for 1005s and seen as modifier
                          :held    50   ;; to_if_held_down_threshold_milliseconds (def: 500)
                          ;; key is fired twice when 500 ms is elapsed (otherwise seen as a hold command)
                          }
                } ;; profiles


  #+end_src
 
* Templates
  #+begin_src clojure
    :templates {
                :km "osascript -e 'tell application \"Keyboard Maestro Engine\" to do script \"%s\"'"
                :open "open \"%s\""
                } ;; templates

  #+end_src
 
* Layers & Simlayers
  #+begin_src clojure
    :layers {

    :tab-mode {:key :tab
               :afterup [{:set ["yabai-move-mode" 0]}
                         {:set ["yabai-focus-mode" 0]}
                         {:set ["yabai-display-mode" 0]}
                         {:set ["chrome-movement-mode" 0]}
                         {:set ["chrome-rearrange-tab-mode" 0]}]}

    :yabai-move-mode {:key :w :condi :tab-mode}
    :yabai-focus-mode {:key :f :condi :tab-mode}
    :yabai-display-mode {:key :d :condi :tab-mode}
    :chrome-movement-mode {:key :t :condi :tab-mode} ;;TODO make this work
    :chrome-history-mode {:key :g :condi :tab-mode} ;;TODO make this work
    :chrome-rearrange-tab-mode {:key :r :condi :tab-mode}
    :vim-mode {:key :z}

    }

    :simlayers {

    :jupyter-mode {:key :j}

    }

  #+end_src
 
* Main
** begin main
   #+begin_src clojure
   :main [{
   :des "see karabiner.org for documentation.",
   :rules [
   #+end_src
** left cmd => cmd+tab
   press left command alone to switch to the previous app.
   #+begin_src clojure
   [:##right_command :right_command nil {:alone :!Ctab}]
   #+end_src
** caps lock alone = escape, with other keys = ctrl
    #+begin_src clojure
    [:##caps_lock :left_control nil {:alone :escape}]
    #+end_src
** yabai-mode(tab+{wsf}+{hjkl})
   #+begin_src clojure
   ;; :yabai-insert-mode
   ;; [:h "/usr/local/bin/yabai -m window --insert west"]
   ;; [:j "/usr/local/bin/yabai -m window --insert south"]
   ;; [:k "/usr/local/bin/yabai -m window --insert north"]
   ;; [:l "/usr/local/bin/yabai -m window --insert east"]

   ;; move windows
   :yabai-move-mode
   [:b "/usr/local/bin/yabai -m space --balance"]
   [:h "/usr/local/bin/yabai -m window --warp west"]
   [:j "/usr/local/bin/yabai -m window --warp south"]
   [:k "/usr/local/bin/yabai -m window --warp north"]
   [:l "/usr/local/bin/yabai -m window --warp east"]
   [:p "/usr/local/bin/yabai -m window --toggle float"]
   [:s "/usr/local/bin/yabai -m window --toggle split"]

   #+end_src
   
** yabai-focus-mode
   #+begin_src clojure
   ;; ;; ;; scale windows
   ;; :yabai-scale-mode
   ;; [:h "/usr/local/bin/yabai -m window --resize left"]
   ;; [:j "/usr/local/bin/yabai -m window --resize down"]
   ;; [:k "/usr/local/bin/yabai -m window --resize up"]
   ;; [:l "/usr/local/bin/yabai -m window --resize right"]

   ;; directionally navigate windows/spaces
   ;; space<=="g", {"h" "j" "k" "l"}, ";"==>space
   :yabai-focus-mode
   [:g "/usr/local/bin/yabai -m space --focus prev"]
   [:h "/usr/local/bin/yabai -m window --focus west"]
   [:j "/usr/local/bin/yabai -m window --focus south"]
   [:k "/usr/local/bin/yabai -m window --focus north"]
   [:l "/usr/local/bin/yabai -m window --focus east"]
   [:semicolon "/usr/local/bin/yabai -m space --focus next"]
   #+end_src

** yabai-display-mode
   #+begin_src clojure
   :yabai-display-mode
   [:j "/usr/local/bin/yabai -m window --display prev && /usr/local/bin/yabai -m display --focus prev"]
   [:k "/usr/local/bin/yabai -m window --display next && /usr/local/bin/yabai -m display --focus next"]
   [:h "/usr/local/bin/yabai -m display --focus prev"]
   [:l "/usr/local/bin/yabai -m display --focus next"]
   #+end_src

** chrome-history-mode (tab+{g}+{hjkl})
   #+begin_src clojure
   :chrome-history-mode
   [:h :!Copen_bracket]
   [:l :!Cclose_bracket]
   #+end_src
** chrome-movement-mode (tab+{t}+{hjkl})
   #+begin_src clojure
   :chrome-movement-mode
   [:h :!TStab]
   [:l :!Ttab]
     #+end_src
** chrome-rearrange-tab-mode (tab+{r}+{hjkl})
   #+begin_src clojure
   ;;NOTE: need the Chrome extension for this to work
   :chrome-rearrange-tab-mode
   ;; [:h :!COdown_arrow]

   [:h :!TSleft_arrow]
   [:l :!TSright_arrow]
   ;; [:l :!COup_arrow]
   #+end_src
** tab-mode (tab)
   #+begin_src clojure
   :tab-mode
   [:spacebar :!CTspacebar]
   [:f8 [:km "Open Spotify"]]
   [:c [:km "Open Chrome"]]
   [:e [:km "Open Emacs"]]
   [:i [:km "Open iTerm"]]
   [:m [:km "Open Messages"]]
   [:n [:km "Open Notes"]]
   ;; [:q [:km "Open Qutebrowser"]]
   ;; [:x [:km "Open Xcode"]]
   ;; [:w [:km "Open Word"]]
   ;; [:y [:km "Open Keyboard Maestro"]]
   [:z [:km "Open Zoom"]]

   #+end_src

** vim-mode (z)
#+begin_src clojure
:vim-mode
[:#Sh :left_arrow] ;; hjkl navigation everywhere + Shift
[:#Sj :down_arrow]
[:#Sk :up_arrow]
[:#Sl :right_arrow]
[:#Sb :!Oleft_arrow]
[:#Sw :!Oright_arrow]
[:delete_or_backspace :!Odelete_or_backspace]
#+end_src

** jupyter mode (j)
   #+begin_src clojure
     :jupyter-mode
     [:l [:km "Start or Go to Existing Jupyter Lab Server"]]

   #+end_src
** end main 
   #+begin_src clojure
    ]}] ;;end main
   #+end_src
   
* Applications
  #+begin_src clojure
    :applications [

    :Emacs ["^org\\.gnu\\.Emacs$"]
    :Chrome ["^com\\.google\\.Chrome$", "^org\\.chromium\\.Chromium$", "^com\\.google\\.Chrome\\.canary$"]

    ]

    };;ending bracket for whole data structure!
  #+end_src
